var app=function(){"use strict";function e(){}function n(e){return e()}function t(){return Object.create(null)}function r(e){e.forEach(n)}function o(e){return"function"==typeof e}function a(e,n){return e!=e?n==n:e!==n||e&&"object"==typeof e||"function"==typeof e}function i(e,n){e.appendChild(n)}function s(e,n,t){e.insertBefore(n,t||null)}function c(e){e.parentNode.removeChild(e)}function l(e){return document.createElement(e)}function u(){return e=" ",document.createTextNode(e);var e}function f(e,n,t,r){return e.addEventListener(n,t,r),()=>e.removeEventListener(n,t,r)}function p(e,n,t){null==t?e.removeAttribute(n):e.getAttribute(n)!==t&&e.setAttribute(n,t)}function d(e,n,t,r){null===t?e.style.removeProperty(n):e.style.setProperty(n,t,r?"important":"")}let v;function m(e){v=e}function h(){if(!v)throw new Error("Function called outside component initialization");return v}function b(){const e=h();return(n,t,{cancelable:r=!1}={})=>{const o=e.$$.callbacks[n];if(o){const a=function(e,n,{bubbles:t=!1,cancelable:r=!1}={}){const o=document.createEvent("CustomEvent");return o.initCustomEvent(e,t,r,n),o}(n,t,{cancelable:r});return o.slice().forEach((n=>{n.call(e,a)})),!a.defaultPrevented}return!0}}const g=[],_=[],w=[],x=[],y=Promise.resolve();let $=!1;function P(e){w.push(e)}const z=new Set;let q=0;function k(){const e=v;do{for(;q<g.length;){const e=g[q];q++,m(e),j(e.$$)}for(m(null),g.length=0,q=0;_.length;)_.pop()();for(let e=0;e<w.length;e+=1){const n=w[e];z.has(n)||(z.add(n),n())}w.length=0}while(g.length);for(;x.length;)x.pop()();$=!1,z.clear(),m(e)}function j(e){if(null!==e.fragment){e.update(),r(e.before_update);const n=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,n),e.after_update.forEach(P)}}const A=new Set;let V;function E(e,n){e&&e.i&&(A.delete(e),e.i(n))}function M(e,n,t,r){if(e&&e.o){if(A.has(e))return;A.add(e),V.c.push((()=>{A.delete(e),r&&(t&&e.d(1),r())})),e.o(n)}}function F(e){e&&e.c()}function C(e,t,a,i){const{fragment:s,on_mount:c,on_destroy:l,after_update:u}=e.$$;s&&s.m(t,a),i||P((()=>{const t=c.map(n).filter(o);l?l.push(...t):r(t),e.$$.on_mount=[]})),u.forEach(P)}function L(e,n){const t=e.$$;null!==t.fragment&&(r(t.on_destroy),t.fragment&&t.fragment.d(n),t.on_destroy=t.fragment=null,t.ctx=[])}function O(e,n){-1===e.$$.dirty[0]&&(g.push(e),$||($=!0,y.then(k)),e.$$.dirty.fill(0)),e.$$.dirty[n/31|0]|=1<<n%31}function T(n,o,a,i,s,l,u,f=[-1]){const p=v;m(n);const d=n.$$={fragment:null,ctx:null,props:l,update:e,not_equal:s,bound:t(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(o.context||(p?p.$$.context:[])),callbacks:t(),dirty:f,skip_bound:!1,root:o.target||p.$$.root};u&&u(d.root);let h=!1;if(d.ctx=a?a(n,o.props||{},((e,t,...r)=>{const o=r.length?r[0]:t;return d.ctx&&s(d.ctx[e],d.ctx[e]=o)&&(!d.skip_bound&&d.bound[e]&&d.bound[e](o),h&&O(n,e)),t})):[],d.update(),h=!0,r(d.before_update),d.fragment=!!i&&i(d.ctx),o.target){if(o.hydrate){const e=function(e){return Array.from(e.childNodes)}(o.target);d.fragment&&d.fragment.l(e),e.forEach(c)}else d.fragment&&d.fragment.c();o.intro&&E(n.$$.fragment),C(n,o.target,o.anchor,o.customElement),k()}m(p)}class B{$destroy(){L(this,1),this.$destroy=e}$on(e,n){const t=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return t.push(n),()=>{const e=t.indexOf(n);-1!==e&&t.splice(e,1)}}$set(e){var n;this.$$set&&(n=e,0!==Object.keys(n).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}var R="undefined"!=typeof Float32Array?Float32Array:Array;function S(){var e=new R(16);return R!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function G(e,n){var t=n[0],r=n[1],o=n[2],a=n[3],i=n[4],s=n[5],c=n[6],l=n[7],u=n[8],f=n[9],p=n[10],d=n[11],v=n[12],m=n[13],h=n[14],b=n[15],g=t*s-r*i,_=t*c-o*i,w=t*l-a*i,x=r*c-o*s,y=r*l-a*s,$=o*l-a*c,P=u*m-f*v,z=u*h-p*v,q=u*b-d*v,k=f*h-p*m,j=f*b-d*m,A=p*b-d*h,V=g*A-_*j+w*k+x*q-y*z+$*P;return V?(V=1/V,e[0]=(s*A-c*j+l*k)*V,e[1]=(o*j-r*A-a*k)*V,e[2]=(m*$-h*y+b*x)*V,e[3]=(p*y-f*$-d*x)*V,e[4]=(c*q-i*A-l*z)*V,e[5]=(t*A-o*q+a*z)*V,e[6]=(h*w-v*$-b*_)*V,e[7]=(u*$-p*w+d*_)*V,e[8]=(i*j-s*q+l*P)*V,e[9]=(r*q-t*j-a*P)*V,e[10]=(v*y-m*w+b*g)*V,e[11]=(f*w-u*y-d*g)*V,e[12]=(s*z-i*k-c*P)*V,e[13]=(t*k-r*z+o*P)*V,e[14]=(m*_-v*x-h*g)*V,e[15]=(u*x-f*_+p*g)*V,e):null}function U(e,n,t,r){var o,a,i,s,c,l,u,f,p,d,v,m,h,b,g,_,w,x,y,$,P,z,q,k,j=r[0],A=r[1],V=r[2],E=Math.hypot(j,A,V);return E<1e-6?null:(j*=E=1/E,A*=E,V*=E,o=Math.sin(t),i=1-(a=Math.cos(t)),s=n[0],c=n[1],l=n[2],u=n[3],f=n[4],p=n[5],d=n[6],v=n[7],m=n[8],h=n[9],b=n[10],g=n[11],_=j*j*i+a,w=A*j*i+V*o,x=V*j*i-A*o,y=j*A*i-V*o,$=A*A*i+a,P=V*A*i+j*o,z=j*V*i+A*o,q=A*V*i-j*o,k=V*V*i+a,e[0]=s*_+f*w+m*x,e[1]=c*_+p*w+h*x,e[2]=l*_+d*w+b*x,e[3]=u*_+v*w+g*x,e[4]=s*y+f*$+m*P,e[5]=c*y+p*$+h*P,e[6]=l*y+d*$+b*P,e[7]=u*y+v*$+g*P,e[8]=s*z+f*q+m*k,e[9]=c*z+p*q+h*k,e[10]=l*z+d*q+b*k,e[11]=u*z+v*q+g*k,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)}function D(){var e=new R(3);return R!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function N(){var e=new R(2);return R!=Float32Array&&(e[0]=0,e[1]=0),e}function H(n){let t,r,o,a;return{c(){t=l("div"),r=l("input"),p(r,"type","range"),p(r,"min","0"),p(r,"max","100"),r.value=n[0],p(r,"class","slider svelte-jjszio"),p(r,"id","myRange"),p(t,"class","slidecontainer svelte-jjszio")},m(e,c){s(e,t,c),i(t,r),o||(a=f(r,"input",n[1]),o=!0)},p(e,[n]){1&n&&(r.value=e[0])},i:e,o:e,d(e){e&&c(t),o=!1,a()}}}function I(e,n,t){const r=b();let{startValue:o=0}=n;return e.$$set=e=>{"startValue"in e&&t(0,o=e.startValue)},[o,function(e){r("slide",{value:e.target.value/100})}]}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)}),D(),function(){var e,n=(e=new R(4),R!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e)}(),function(){var e=N()}();class Y extends B{constructor(e){super(),T(this,e,I,H,a,{startValue:0})}}function W(n){let t;return{c(){t=l("h6"),t.textContent='No GPU adapter found! Try updating chrome and enabling the experimental\n\t\tflag "#enable-unsafe-webgpu" under "chrome://flags.',d(t,"color","black"),d(t,"justify-content","center"),d(t,"display","flex"),d(t,"position","absolute"),d(t,"bottom","0"),d(t,"width","100vw"),p(t,"class","svelte-1tth5b6")},m(e,n){s(e,t,n)},p:e,i:e,o:e,d(e){e&&c(t)}}}function X(n){let t,o,a,v,m,h,b,g,_,w,x,y,$,P,z,q,k,j,A,V,O,T,B,R,S,G,U,D,N,H,I,W,X,J,K,Q,Z,ee,ne,te,re,oe,ae,ie,se,ce,le,ue,fe,pe;return a=new Y({props:{startValue:50}}),a.$on("slide",n[4]),g=new Y({props:{startValue:16}}),g.$on("slide",n[5]),$=new Y({props:{startValue:0}}),$.$on("slide",n[6]),V=new Y({props:{startValue:15}}),V.$on("slide",n[8]),G=new Y({props:{startValue:25}}),G.$on("slide",n[9]),I=new Y({props:{startValue:0}}),I.$on("slide",n[10]),Q=new Y({props:{startValue:0}}),Q.$on("slide",n[11]),ae=new Y({props:{startValue:0}}),ae.$on("slide",n[13]),{c(){t=l("div"),o=l("span"),F(a.$$.fragment),v=u(),m=l("h6"),m.textContent="iteration_count",h=u(),b=l("span"),F(g.$$.fragment),_=u(),w=l("h6"),w.textContent="fractal_power",x=u(),y=l("span"),F($.$$.fragment),P=u(),z=l("h6"),z.textContent="color",q=u(),k=l("h6"),k.textContent="[randomize]",j=u(),A=l("span"),F(V.$$.fragment),O=u(),T=l("h6"),T.textContent="noise",B=u(),R=l("div"),S=l("span"),F(G.$$.fragment),U=u(),D=l("h6"),D.textContent="chromatic_abberation",N=u(),H=l("span"),F(I.$$.fragment),W=u(),X=l("h6"),X.textContent="normal_strenght",J=u(),K=l("span"),F(Q.$$.fragment),Z=u(),ee=l("h6"),ee.textContent="randomness",ne=u(),te=l("h6"),te.textContent="[reseed]",re=u(),oe=l("span"),F(ae.$$.fragment),ie=u(),se=l("h6"),se.textContent="wobble_speed",ce=u(),le=l("h6"),le.textContent="- x -",p(m,"class","svelte-1tth5b6"),p(o,"class","svelte-1tth5b6"),p(w,"class","svelte-1tth5b6"),p(b,"class","svelte-1tth5b6"),p(z,"class","svelte-1tth5b6"),p(k,"class","bg-inverse svelte-1tth5b6"),p(y,"class","svelte-1tth5b6"),p(T,"class","svelte-1tth5b6"),p(A,"class","svelte-1tth5b6"),p(t,"class","svelte-1tth5b6"),p(D,"class","svelte-1tth5b6"),p(S,"class","svelte-1tth5b6"),p(X,"class","svelte-1tth5b6"),p(H,"class","svelte-1tth5b6"),p(ee,"class","svelte-1tth5b6"),p(te,"class","bg-inverse svelte-1tth5b6"),p(K,"class","svelte-1tth5b6"),p(se,"class","svelte-1tth5b6"),p(oe,"class","svelte-1tth5b6"),p(R,"class","right svelte-1tth5b6"),d(le,"position","absolute"),d(le,"bottom","0"),d(le,"width","100vw"),d(le,"text-align","center"),d(le,"margin","0"),d(le,"transform","translateY(-10px)"),p(le,"class","svelte-1tth5b6")},m(e,r){s(e,t,r),i(t,o),C(a,o,null),i(o,v),i(o,m),i(t,h),i(t,b),C(g,b,null),i(b,_),i(b,w),i(t,x),i(t,y),C($,y,null),i(y,P),i(y,z),i(y,q),i(y,k),i(t,j),i(t,A),C(V,A,null),i(A,O),i(A,T),s(e,B,r),s(e,R,r),i(R,S),C(G,S,null),i(S,U),i(S,D),i(R,N),i(R,H),C(I,H,null),i(H,W),i(H,X),i(R,J),i(R,K),C(Q,K,null),i(K,Z),i(K,ee),i(K,ne),i(K,te),i(R,re),i(R,oe),C(ae,oe,null),i(oe,ie),i(oe,se),s(e,ce,r),s(e,le,r),ue=!0,fe||(pe=[f(k,"click",n[7]),f(te,"click",n[12])],fe=!0)},p:e,i(e){ue||(E(a.$$.fragment,e),E(g.$$.fragment,e),E($.$$.fragment,e),E(V.$$.fragment,e),E(G.$$.fragment,e),E(I.$$.fragment,e),E(Q.$$.fragment,e),E(ae.$$.fragment,e),ue=!0)},o(e){M(a.$$.fragment,e),M(g.$$.fragment,e),M($.$$.fragment,e),M(V.$$.fragment,e),M(G.$$.fragment,e),M(I.$$.fragment,e),M(Q.$$.fragment,e),M(ae.$$.fragment,e),ue=!1},d(e){e&&c(t),L(a),L(g),L($),L(V),e&&c(B),e&&c(R),L(G),L(I),L(Q),L(ae),e&&c(ce),e&&c(le),fe=!1,r(pe)}}}function J(e){let n,t,o,a,i,f,v,m,h,b,g,_,w,x,y,$,P;const z=[X,W],q=[];function k(e,n){return e[2]?0:1}return n=k(e),t=q[n]=z[n](e),{c(){t.c(),o=u(),a=l("h6"),a.innerHTML="|<br/>\n\t|<br/>\n\t+--",i=u(),f=l("h6"),f.innerHTML="|<br/>\n\t|<br/>\n\t--+",v=u(),m=l("div"),m.innerHTML='<h6 style="margin-top: 12px; height: fit-content;" class="black bg-inverse svelte-1tth5b6">mandelbulb_explorer</h6>',h=u(),b=l("canvas"),g=u(),_=l("link"),w=u(),x=l("link"),y=u(),$=l("link"),p(a,"class","black svelte-1tth5b6"),d(a,"position","absolute"),d(a,"bottom","0"),p(f,"class","black svelte-1tth5b6"),d(f,"position","absolute"),d(f,"bottom","0"),d(f,"right","0"),d(f,"text-align","right"),d(m,"width","100vw"),d(m,"display","flex"),d(m,"justify-content","center"),p(m,"class","svelte-1tth5b6"),p(b,"height","2000"),p(b,"width","2000"),p(b,"class","svelte-1tth5b6"),p(_,"rel","preconnect"),p(_,"href","https://fonts.googleapis.com"),p(x,"rel","preconnect"),p(x,"href","https://fonts.gstatic.com"),p(x,"crossorigin",""),p($,"href","https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"),p($,"rel","stylesheet")},m(t,r){q[n].m(t,r),s(t,o,r),s(t,a,r),s(t,i,r),s(t,f,r),s(t,v,r),s(t,m,r),s(t,h,r),s(t,b,r),e[14](b),s(t,g,r),s(t,_,r),s(t,w,r),s(t,x,r),s(t,y,r),s(t,$,r),P=!0},p(e,[a]){let i=n;n=k(e),n===i?q[n].p(e,a):(V={r:0,c:[],p:V},M(q[i],1,1,(()=>{q[i]=null})),V.r||r(V.c),V=V.p,t=q[n],t?t.p(e,a):(t=q[n]=z[n](e),t.c()),E(t,1),t.m(o.parentNode,o))},i(e){P||(E(t),P=!0)},o(e){M(t),P=!1},d(t){q[n].d(t),t&&c(o),t&&c(a),t&&c(i),t&&c(f),t&&c(v),t&&c(m),t&&c(h),t&&c(b),e[14](null),t&&c(g),t&&c(_),t&&c(w),t&&c(x),t&&c(y),t&&c($)}}}function K(e){var n=new Float32Array(16);let t=Math.tan(e.fieldOfView*Math.PI/360),r=e.aspectRatio*t;return n[0]=1/r,n[5]=1/t,n[10]=e.far/(e.far-e.near),n[14]=-e.far*e.near/(e.far-e.near),n[11]=1,n}function Q(e,n,t){class r{}function o(){return e=Math.random(),n=Math.random(),t=Math.random(),r=1,(o=new R(4))[0]=e,o[1]=n,o[2]=t,o[3]=r,o;var e,n,t,r,o}function a(){return[o(),o(),o()]}class i{constructor(){this.x=0,this.y=0,this.z=2,this.color=0,this.noise=.15,this.chromaticAberration=.25,this.normals=0,this.iterations=10,this.power=8,this.randomness=0,this.wobble=0,this.seed=100*Math.random(),this.colors=a();const e=new r;e.aspectRatio=c.clientWidth/c.clientHeight,e.fieldOfView=45,e.near=.1,e.far=100,this.mouse=N(),this.projection=K(e)}}let s,c,l=!1;async function u(){function e(){console.error('No GPU adapter found! Try enabling the experimental flag "#enable-unsafe-webgpu" under "chrome://flags"')}if(null==navigator.gpu)return void e();const n=await navigator.gpu.requestAdapter();n||e(),t(2,l=!0),document.querySelectorAll("h6").forEach((e=>e.classList.remove("black")));const o=await n.requestDevice(),a=c.getContext("webgpu"),i=window.devicePixelRatio||1,u=[c.clientWidth*i,c.clientHeight*i],f=navigator.gpu.getPreferredCanvasFormat();a.configure({device:o,format:f,size:u});const p=o.createShaderModule({code:"// Vertex shader\n\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) position: vec3<f32>,\n    @location(1) ray: vec3<f32>,\n    @location(2) screen_coordinates: vec2<f32>\n};\n\nstruct InputData {\n    projection: mat4x4<f32>,\n    inverse_projection: mat4x4<f32>,\n    inverse_view: mat4x4<f32>,\n    camera_position: vec3<f32>,\n    time: f32,\n    color: f32,\n    noise: f32,\n    chromatic_aberration: f32,\n    iterations: f32,\n    power: f32,\n    normals: f32,\n    randomness: f32,\n    wobble_speed: f32,\n    seed: f32,\n    color1: vec4<f32>,\n    color2: vec4<f32>,\n    color3: vec4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> input_data: InputData;\n\n\nfn signed_distance_to_sphere(pos: vec3<f32>, radius: f32) -> f32 {\n    return length(pos) - radius;\n}\n\nfn signed_distance_to_cube(pos: vec3<f32>, size: f32) -> f32 {\n    let q = abs(pos) - size;\n    return length(max(q, vec3<f32>(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct PolarSphere {\n    q: f32,\n    f: f32,\n    t: f32,\n}\n\nfn to_polar_sphere(pos: vec3<f32>) -> PolarSphere {\n    var sphere = PolarSphere();\n    sphere.q = length(pos);\n    sphere.f = atan2(pos.y, pos.x);\n    sphere.t = acos(pos.z / sphere.q);\n    return sphere;\n}\n\nfn pow_polar_sphere(sphere: PolarSphere, p: f32) -> PolarSphere {\n    var new_sphere = PolarSphere();\n    new_sphere.q = pow(sphere.q, p);\n    new_sphere.f = p * sphere.f;\n    new_sphere.t = p * sphere.t;\n    return new_sphere;\n}\n\nfn from_polar_sphere(sphere: PolarSphere) -> vec3<f32> {\n    return vec3(\n        sphere.q * sin(sphere.t) * cos(sphere.f),\n        sphere.q * sin(sphere.t) * sin(sphere.f),\n        sphere.q * cos(sphere.t)\n    );\n}\n\nfn signed_distance_to_sierpinsky(pos: vec3<f32>, iterations: u32, scale: f32) -> f32 {\n    var z = pos;\n\n    let a1 = vec3<f32>(1.0, 1.0, 1.0);\n    let a2 = vec3<f32>(-1.0, -1.0, 1.0);\n    let a3 = vec3<f32>(1.0, -1.0, -1.0);\n    let a4 = vec3<f32>(-1.0, 1.0, -1.0);\n    var c = vec3<f32>(0.0, 0.0, 0.0);\n    let n = 0;\n    var dist = 0.0;\n    var d = 0.0;\n    for (var i = 0u; i < iterations; i = i + 1u) {\n        c = a1;\n        dist = length(z - a1);\n        d = length(z - a2); if d < dist { c = a2; dist = d; }\n        d = length(z - a3); if d < dist { c = a3; dist = d; }\n        d = length(z - a4); if d < dist { c = a4; dist = d; }\n        z = scale * z - c * (scale - 1.0);\n    }\n\n    return length(z) * pow(scale, f32(-n));\n}\n\nfn signed_distance_to_ocahedron(pos: vec3<f32>, size: f32) -> f32 {\n    let p = abs(pos);\n    return (p.x + p.y + p.z - size) * 0.57735027;\n}\n\nfn signed_distance_to_mandelbulb(pos: vec3<f32>, iterations: u32, power: f32) -> f32 {\n    var z = pos;\n    var q = 0.0;\n    var dr = 1.0;\n\n    for (var i = 0u; i < iterations; i = i + 1u) {\n        let polar = to_polar_sphere(z);\n        q = polar.q;\n\n        if q > 2.0 {\n            break;\n        }\n\n        dr = pow(q, power - 1.0) * power * dr + 1.0;\n\n        let polar_pow = pow_polar_sphere(polar, power);\n\n        let pow_cartesian = from_polar_sphere(polar_pow);\n\n        z = pow_cartesian + pos;\n    }\n    return 0.5 * log(q) * q / dr;\n}\n\nfn rand(co: vec2<f32>) -> f32 {\n    return fract(sin(dot(co.xy, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn rand_3d(coord: vec3<f32>) -> f32 {\n    var c = abs(coord);\n    c = c % (10000.0 * vec3<f32>(1.0));\n    return fract(sin(dot(coord, vec3<f32>(12.9898, 78.233, 71.325))) * 43758.5453);\n}\n\nfn perlin_noise(coord: vec3<f32>) -> f32 {\n    var c = coord;\n    c = c * 20.0;\n    c = c % (10000.0 * vec3<f32>(1.0));\n\n    var i: vec3<f32> = floor(c);\n    var f: vec3<f32> = fract(c);\n\n    var cube = array<array<array<f32, 2>, 2>, 2>();\n    cube[0][0][0] = rand_3d(i) * 6.28318;\n    cube[1][0][0] = rand_3d(i + vec3<f32>(1.0, 0.0, 0.0)) * 6.28318;\n    cube[0][1][0] = rand_3d(i + vec3<f32>(0.0, 1.0, 0.0)) * 6.28318;\n    cube[0][0][1] = rand_3d(i + vec3<f32>(0.0, 0.0, 1.0)) * 6.28318;\n    cube[1][1][0] = rand_3d(i + vec3<f32>(1.0, 1.0, 0.0)) * 6.28318;\n    cube[0][1][1] = rand_3d(i + vec3<f32>(0.0, 1.0, 1.0)) * 6.28318;\n    cube[1][0][1] = rand_3d(i + vec3<f32>(1.0, 0.0, 1.0)) * 6.28318;\n    cube[1][1][1] = rand_3d(i + vec3<f32>(1.0, 1.0, 1.0)) * 6.28318;\n\n    var vectors = array<array<array<vec3<f32>, 2>, 2>, 2>();\n    vectors[0][0][0] = vec3(-sin(cube[0][0][0]), cos(cube[0][0][0]), -cos(cube[0][0][0]));\n    vectors[1][0][0] = vec3(-sin(cube[1][0][0]), cos(cube[1][0][0]), -cos(cube[1][0][0]));\n    vectors[0][1][0] = vec3(-sin(cube[0][1][0]), cos(cube[0][1][0]), -cos(cube[0][1][0]));\n    vectors[0][0][1] = vec3(-sin(cube[0][0][1]), cos(cube[0][0][1]), -cos(cube[0][0][1]));\n    vectors[1][1][0] = vec3(-sin(cube[1][1][0]), cos(cube[1][1][0]), -cos(cube[1][1][0]));\n    vectors[0][1][1] = vec3(-sin(cube[0][1][1]), cos(cube[0][1][1]), -cos(cube[0][1][1]));\n    vectors[1][0][1] = vec3(-sin(cube[1][0][1]), cos(cube[1][0][1]), -cos(cube[1][0][1]));\n    vectors[1][1][1] = vec3(-sin(cube[1][1][1]), cos(cube[1][1][1]), -cos(cube[1][1][1]));\n\n    var dots = array<array<array<f32, 2>, 2>, 2>();\n    dots[0][0][0] = dot(vectors[0][0][0], f);\n    dots[1][0][0] = dot(vectors[1][0][0], f - vec3<f32>(1.0, 0.0, 0.0));\n    dots[0][1][0] = dot(vectors[0][1][0], f - vec3<f32>(0.0, 1.0, 0.0));\n    dots[0][0][1] = dot(vectors[0][0][1], f - vec3<f32>(0.0, 0.0, 1.0));\n    dots[1][1][0] = dot(vectors[1][1][0], f - vec3<f32>(1.0, 1.0, 0.0));\n    dots[0][1][1] = dot(vectors[0][1][1], f - vec3<f32>(0.0, 1.0, 1.0));\n    dots[1][0][1] = dot(vectors[1][0][1], f - vec3<f32>(1.0, 0.0, 1.0));\n    dots[1][1][1] = dot(vectors[1][1][1], f - vec3<f32>(1.0, 1.0, 1.0));\n\n    var cubic: vec3<f32> = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(\n            mix(dots[0][0][0], dots[1][0][0], cubic.x),\n            mix(dots[0][1][0], dots[1][1][0], cubic.x),\n            cubic.y\n        ),\n        mix(\n            mix(dots[0][0][1], dots[1][0][1], cubic.x),\n            mix(dots[0][1][1], dots[1][1][1], cubic.x),\n            cubic.y\n        ),\n        cubic.z\n    ) + 0.5;\n}\n\n// fn noise\n\nfn map(pos: vec3<f32>) -> f32 {\n    var repeat = cos(pos);\n    if input_data.randomness != 0.0 {\n        let r = perlin_noise(pos * input_data.randomness + input_data.seed + input_data.time * input_data.wobble_speed) * 2.0 - 1.0;\n        repeat = repeat + r;\n    }\n    let d3 = signed_distance_to_mandelbulb(repeat, u32(input_data.iterations), input_data.power);\n\n    return d3;\n\n    // return smooth_min(\n    //     d1,\n    //     d2,\n    //     .2\n    // );\n}\n\nfn colored_map(pos: vec3<f32>) -> vec2<f32> {\n    let otherpos = pos + vec3<f32>(.5 * sin(input_data.time), 0.0, 0.0);\n    let d1 = signed_distance_to_sphere(pos, 0.2);\n    let d2 = signed_distance_to_cube(otherpos, 0.1);\n\n    let m = smooth_min(\n        d1,\n        d2,\n        .2\n    );\n\n    return vec2<f32>(m, clamp((d1 - d2) / .2, 0.0, 1.0));\n}\n\nfn smooth_min(a: f32, b: f32, smoothing: f32) -> f32 {\n    let h = max(smoothing - abs(a - b), 0.0) / smoothing;\n    return min(a, b) - h * h * h * smoothing / 6.0;\n}\n\nfn normal(pos: vec3<f32>) -> vec3<f32> {\n    let eps = 0.001;\n\n    let normal = vec3<f32>(\n        map(pos + vec3<f32>(eps, 0.0, 0.0)) - map(pos + vec3<f32>(-eps, 0.0, 0.0)),\n        map(pos + vec3<f32>(0.0, eps, 0.0)) - map(pos + vec3<f32>(0.0, -eps, 0.0)),\n        map(pos + vec3<f32>(0.0, 0.0, eps)) - map(pos + vec3<f32>(0.0, 0.0, -eps))\n    );\n    return normalize(normal);\n}\n\nfn raymarch(position: vec3<f32>, ray: vec3<f32>) -> vec4<f32> {\n    var ret = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n\n    let max_steps: u32 = 1024u;\n    let threshold: f32 = 0.001;\n\n    var t = 0.0;\n\n    var traveled = 0.0;\n\n    var glow_color = vec4<f32>(0.0, 0.0, 1.0, 1.0);\n\n    for (var i = 0u; i < max_steps; i = i + 1u) {\n        let p = position + ray * t;\n\n        let d = map(p);\n        traveled = traveled + d;\n\n        if d > 1000.0 {\n            break;\n        }\n\n        // ret.z = ret.z - .003;\n\n        if d < threshold {\n            let lightDir = normalize(vec3<f32>(0.0, 1.0, -1.0));\n\n            let color1 = vec3<f32>(217.0, 3.0, 104.0) / 255.0;\n            let color2 = vec3<f32>(241.0, 196.0, 15.0) / 255.0;\n            let color3 = vec3<f32>(34.0, 116.0, 165.0) / 255.0;\n\n            let color_difference = 10.0;\n\n            var steps = f32(i) / f32(max_steps);\n            steps = steps * 5.0 - 0.8;\n\n            let mix1 = mix(\n                input_data.color1.rgb,\n                input_data.color2.rgb,\n                sin(steps * color_difference)\n            );\n\n            let mix2 = mix(\n                mix1,\n                input_data.color3.rgb,\n                sin(steps * color_difference + color_difference / 2.0)\n            );\n\n            let color = mix(\n                vec3<f32>(1.0) * f32(i) / f32(max_steps) + .2,\n                mix2 + abs(steps),\n                input_data.color\n            );\n\n\n            var l = 0.0;\n            if input_data.normals != 0.0 {\n                l = dot(normal(p), lightDir);\n            }\n            ret = vec4<f32>(vec3<f32>(1.0) * color * mix(1.0, l, input_data.normals), 1.0);\n            break;\n        }\n\n        t = t + d;\n    }\n\n    return ret;\n}\n\n@vertex\nfn vs_main(\n    @builtin(vertex_index) in_vertex_index: u32,\n) -> VertexOutput {\n    var positions = array<vec2<f32>, 4>(\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(1.0, -1.0),\n        vec2<f32>(-1.0, 1.0),\n        vec2<f32>(1.0, 1.0),\n    );\n\n\n    var out: VertexOutput;\n    var pos = vec3<f32>(positions[in_vertex_index].xy, 0.0);\n\n    out.clip_position = vec4<f32>(pos, 1.0);\n\n    out.position = pos;\n\n    out.screen_coordinates = pos.xy;\n\n    pos.z = 1.0;\n    out.ray = (input_data.projection * input_data.inverse_projection * vec4<f32>(pos, 1.0)).xyz;\n\n    return out;\n}\n\n// Fragment shader\n    \n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    let sphere_pos = vec3<f32>(0.0, 0.0, 2.0);\n\n    var color = raymarch(-input_data.camera_position + vec3<f32>(0.0, 0.0, -1.0), normalize(in.ray));\n\n    let v = length(in.screen_coordinates / 5.0) / 1.0;\n\n    color.x = color.x - v;\n    color.y = color.y - v;\n    color.z = color.z - v;\n    return vec4<f32>(color);\n}\n "}),d=o.createShaderModule({code:"// Vertex shader\n\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) position: vec2<f32>,\n};\n\n\nstruct InputData {\n    projection: mat4x4<f32>,\n    inverse_projection: mat4x4<f32>,\n    inverse_view: mat4x4<f32>,\n    camera_position: vec3<f32>,\n    time: f32,\n    color: f32,\n    noise: f32,\n    chromatic_aberration: f32,\n    iterations: f32,\n    power: f32,\n    normals: f32,\n};\n\n@binding(0) @group(0) var postSampler: sampler;\n@binding(1) @group(0) var postTexture: texture_2d<f32>;\n@binding(2) @group(0) var<uniform> input_data: InputData;\n\n@vertex\nfn vs_main(\n    @builtin(vertex_index) in_vertex_index: u32,\n) -> VertexOutput {\n    var out: VertexOutput;\n\n    var positions = array<vec2<f32>, 4>(\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(1.0, -1.0),\n        vec2<f32>(-1.0, 1.0),\n        vec2<f32>(1.0, 1.0),\n    );\n\n    out.clip_position = vec4<f32>(positions[in_vertex_index], 0.0, 1.0);\n\n    out.position = positions[in_vertex_index];\n    out.position.y = -out.position.y;\n\n    return out;\n}\n\nfn to_uv_coords(pos: vec2<f32>) -> vec2<f32> {\n    return vec2<f32>(\n        (pos.x + 1.0) * 0.5,\n        (pos.y + 1.0) * 0.5,\n    );\n}\n\nfn distort(pos: vec2<f32>, amount: f32) -> vec2<f32> {\n    return pos * (1.0 - length(pos) * amount);\n}\n\nfn sample(pos: vec2<f32>) -> vec4<f32> {\n    let uv = to_uv_coords(pos);\n    let image = textureSample(postTexture, postSampler, uv);\n    return image;\n}\n\nfn chromatic_aberration(pos: vec2<f32>, amount: f32, over_distort: f32) -> vec4<f32> {\n    let r = distort(pos, (amount - over_distort) * 1.50917);\n    let g = distort(pos, (amount) * 1.51124);\n    let b = distort(pos, (amount + over_distort) * 1.51690);\n\n    return vec4<f32>(\n        sample(r).r,\n        sample(g).g,\n        sample(b).b,\n        1.0\n    );\n}\n\nfn rand(co: vec2<f32>) -> f32 {\n    return fract(sin(dot(co.xy, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn noise(pos: vec2<f32>, amount: f32) -> f32 {\n    let r = (rand(pos + input_data.time / 10.0) * 2.0 - 1.0);\n    return amount * r;\n}\n\n// Fragment shader\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    var image = chromatic_aberration(in.position, input_data.chromatic_aberration * 0.1, input_data.chromatic_aberration * .03);\n    image = image + noise(in.position, input_data.noise);\n    return image;\n}"}),v=o.createTexture({size:u,format:f,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),m=o.createSampler({magFilter:"linear",minFilter:"linear"}),h=o.createRenderPipeline({layout:"auto",vertex:{module:d,entryPoint:"vs_main"},fragment:{module:d,entryPoint:"fs_main",targets:[{format:f}]},primitive:{topology:"triangle-strip"}}),b=o.createRenderPipeline({layout:"auto",vertex:{module:p,entryPoint:"vs_main"},fragment:{module:p,entryPoint:"fs_main",targets:[{format:f}]},primitive:{topology:"triangle-strip"}}),g=o.createBuffer({size:304,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=o.createBindGroup({layout:b.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}}]}),w=o.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:m},{binding:1,resource:v.createView()},{binding:2,resource:{buffer:g}}]});var x={},y=performance.now();c.addEventListener("click",(e=>{t(1,c.requestPointerLock=c.requestPointerLock||c.webkitRequestPointerLock||c.mozRequestPointerLock,c),c.requestPointerLock()})),document.addEventListener("mousemove",(function(e){if(document.pointerLockElement===c||document.mozPointerLockElement===c||document.webkitPointerLockElement===c){var n=e.movementX||e.mozMovementX||e.webkitMovementX||0,r=e.movementY||e.mozMovementY||e.webkitMovementY||0;t(0,s.mouse[0]+=n,s),t(0,s.mouse[1]+=r,s)}}),!1),document.addEventListener("keydown",(e=>{x[e.key]=!0})),document.addEventListener("keyup",(e=>{x[e.key]=!1})),t(1,c.width=window.innerWidth*window.devicePixelRatio||1,c),t(1,c.height=window.innerHeight*window.devicePixelRatio||1,c),window.addEventListener("resize",(()=>{t(1,c.width=window.innerWidth*window.devicePixelRatio||1,c),t(1,c.height=window.innerHeight*window.devicePixelRatio||1,c);const e=new r;e.aspectRatio=c.clientWidth/c.clientHeight,e.fieldOfView=45,e.near=.1,e.far=100,t(0,s.projection=K(e),s)})),requestAnimationFrame((function e(){if(!a)return;const n=.01;let r=D();x.w&&(r[2]-=n),x.s&&(r[2]+=n),x.d&&(r[0]-=n),x.a&&(r[0]+=n),x.e&&(r[1]-=n),x.q&&(r[1]+=n),x.r;const i=o.createCommandEncoder();var c,l,u,f,p,d,m,$,P,z,q,k,j,A,V,E,M,F=(c=s.projection[0],l=s.projection[1],u=s.projection[2],f=s.projection[3],p=s.projection[4],d=s.projection[5],m=s.projection[6],$=s.projection[7],P=s.projection[8],z=s.projection[9],q=s.projection[10],k=s.projection[11],j=s.projection[12],A=s.projection[13],V=s.projection[14],E=s.projection[15],(M=new R(16))[0]=c,M[1]=l,M[2]=u,M[3]=f,M[4]=p,M[5]=d,M[6]=m,M[7]=$,M[8]=P,M[9]=z,M[10]=q,M[11]=k,M[12]=j,M[13]=A,M[14]=V,M[15]=E,M),C=S();U(C,C,s.mouse[0]/1e3,[0,1,0]),U(C,C,s.mouse[1]/300,[1,0,0]);let L=S();G(L,C);let O=r[1];r[1]=0,function(e,n,t){var r=n[0],o=n[1],a=n[2],i=t[3]*r+t[7]*o+t[11]*a+t[15];i=i||1,e[0]=(t[0]*r+t[4]*o+t[8]*a+t[12])/i,e[1]=(t[1]*r+t[5]*o+t[9]*a+t[13])/i,e[2]=(t[2]*r+t[6]*o+t[10]*a+t[14])/i}(r,r,C),t(0,s.x+=r[0],s),t(0,s.y+=O,s),t(0,s.z+=r[2],s);let T=S();G(T,F),function(e,n,t){var r=n[0],o=n[1],a=n[2],i=n[3],s=n[4],c=n[5],l=n[6],u=n[7],f=n[8],p=n[9],d=n[10],v=n[11],m=n[12],h=n[13],b=n[14],g=n[15],_=t[0],w=t[1],x=t[2],y=t[3];e[0]=_*r+w*s+x*f+y*m,e[1]=_*o+w*c+x*p+y*h,e[2]=_*a+w*l+x*d+y*b,e[3]=_*i+w*u+x*v+y*g,_=t[4],w=t[5],x=t[6],y=t[7],e[4]=_*r+w*s+x*f+y*m,e[5]=_*o+w*c+x*p+y*h,e[6]=_*a+w*l+x*d+y*b,e[7]=_*i+w*u+x*v+y*g,_=t[8],w=t[9],x=t[10],y=t[11],e[8]=_*r+w*s+x*f+y*m,e[9]=_*o+w*c+x*p+y*h,e[10]=_*a+w*l+x*d+y*b,e[11]=_*i+w*u+x*v+y*g,_=t[12],w=t[13],x=t[14],y=t[15],e[12]=_*r+w*s+x*f+y*m,e[13]=_*o+w*c+x*p+y*h,e[14]=_*a+w*l+x*d+y*b,e[15]=_*i+w*u+x*v+y*g}(F,F,C),o.queue.writeBuffer(g,0,new Float32Array(C));var B=performance.now();B=(B-y)/1e3,o.queue.writeBuffer(g,64,new Float32Array(T)),o.queue.writeBuffer(g,128,new Float32Array(L)),o.queue.writeBuffer(g,192,new Float32Array([s.x,s.y,s.z])),o.queue.writeBuffer(g,204,new Float32Array([B,s.color,s.noise,s.chromaticAberration,s.iterations,s.power,s.normals,s.randomness,s.wobble,s.seed])),o.queue.writeBuffer(g,244,new Float32Array(s.colors[0])),o.queue.writeBuffer(g,260,new Float32Array(s.colors[1])),o.queue.writeBuffer(g,276,new Float32Array(s.colors[2]));const N=a.getCurrentTexture().createView(),H={colorAttachments:[{view:v.createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},I={colorAttachments:[{view:N,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},Y=i.beginRenderPass(H);Y.setPipeline(b),Y.setBindGroup(0,_),Y.draw(4),Y.end();const W=i.beginRenderPass(I);W.setPipeline(h),W.setBindGroup(0,w),W.draw(4),W.end(),o.queue.submit([i.finish()]),requestAnimationFrame(e)}))}var f,p,d,v,m;f=0,p=0,d=-1,(v=new R(3))[0]=f,v[1]=p,v[2]=d,m=()=>{u(),t(0,s=new i)},h().$$.on_mount.push(m);return[s,c,l,a,e=>t(0,s.iterations=20*e.detail.value,s),e=>t(0,s.power=50*e.detail.value,s),e=>t(0,s.color=e.detail.value,s),()=>t(0,s.colors=a(),s),e=>t(0,s.noise=e.detail.value,s),e=>t(0,s.chromaticAberration=e.detail.value,s),e=>t(0,s.normals=e.detail.value,s),e=>t(0,s.randomness=e.detail.value/10,s),()=>t(0,s.seed=100*Math.random(),s),e=>t(0,s.wobble=e.detail.value/20,s),function(e){_[e?"unshift":"push"]((()=>{c=e,t(1,c)}))}]}return new class extends B{constructor(e){super(),T(this,e,Q,J,a,{})}}({target:document.body})}();
//# sourceMappingURL=bundle.js.map
